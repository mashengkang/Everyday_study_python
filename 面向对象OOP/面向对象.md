# 面向对象-OOP

## 面向对象编程的基本实现

> 如果需要实例一个对象,那么需要先抽象一个类

如果创建一个类?    通过class关键字来定义一个类

```python
# 定义一个汽车的类
class Cats():
	pass
	
'''
类名的书写规范,建议使用驼峰命名法
    大驼峰: MyCar XiaoMa
    小驼峰:myCar xiaoMa
'''
```

类中需要声明什么内容?

```
一个类有特征和功能两个内容组成:
    特征就是要给描述:白色, 品牌:奥迪, 排量...
    功能就是一个能力: 拉货,带美女兜风...

    特征在编程中就是一个变量,在类中,称为 属性
    功能在编程中就是一个函数,在类中,称为 方法
类中属性一般定义在前面,方法定义在后面
```

实例

```python
# 定义一个汽车的类
class Cars():
    # 属性(特征) 变量
    color = '白色'
    brand = '奥迪'
    pailinag = 2.5

    # 方法(功能) 函数
    def lahuo(self):
        print('小汽车能拉货')

    def doufeng(self):
        print('小汽车能兜风')
```

如何通过类实例化对象并使用?

```python
# 如何使用这个类?
# 通过类实例化一个对象
aodiobj = Cars()
print(aodiobj, type(aodiobj))
# <__main__.Cars object at 0x0000021B7CE9B610> <class '__main__.Cars'>

# 调用对象的 方法
aodiobj.lahuo()  # 小汽车能拉货
aodiobj.doufeng()  # 小汽车能兜风
```

### 成员属性和成员方法的操作

#### 对象操作成员

```
成员属性:
访问: 对象.成员属性名
修改: 对象.成员属性名 = 新值	(此时等于给这个对象创建了一个自己的属性)
添加: 对象.新成员属性 = 值	(此时是给这个对象自己新建了一个属性)
删除: del 对象.成员属性	(注意:只能删除这个对象自己的属性)

成员方法:
访问: 对象.成员方法名
修改: 对象.成员方法名 = func	(此时等于给这个对象创建了一个自己的方法,方法func不加括号)
添加: 对象.方法名 = func	(此时是给这个对象自己新建了一个方法,func不加括号)
删除: del 对象.方法名	(注意:只能删除这个对象自己的方法)
```

#### 类操作成员(不推荐)

```
成员属性:
访问: 类名.成员属性名
修改: 类名.成员属性名 = 新值	(此时通过这个类创建的对象都具有这个属性)
添加: 类名.新成员属性 = 值	(此时是给这个对象自己新建了一个属性)
删除: del 类名.成员属性	(注意:删除这个类的属性后,这个类创建的对象也没有这个属性了)

成员方法:
访问: 类名.成员方法名
修改: 类名.成员方法名 = func	(此时等于给这个对象创建了一个自己的方法,方法func不加括号)
添加: 类名.方法名 = func	(此时是给这个对象自己新建了一个方法,func不加括号)
删除: del 类名.方法名	(注意:只能删除这个对象自己的方法)
```

#### 总结

- 一个类可以实例化处多个对象,每个对象在内存中都独立存在
- 当通过类实例化对象时,并不会把类中成员复制一份给对象,而是给对象了一个引用
- 访问对象成员的时候,如果对象自己没有这个成员,对象会向实例化它的类去查找
- 对象成员添加和修改,都只会影响当前对象自己,不会影响类和其他对象 
- 删除对象的成员时,必须是该对象自己具体的成员才可以,不能删除类中引用的成员
- 对类的成员操作,会影响通过这个类创建的对象,包括之前创建的

### 成员方法中的self

- self'在方法中只是一个形参,并不是关键字
- self 单词本身的意思是自己
- self 在类的方法中 代表 当前这个对象
- self 代表调用这个方法的对象
- self 就可以在类的内部代替对象进行各种操作

**方法的分类**

- 含有self或者可以接受对象作为参数的方法,非绑定类方法
- 不含self或者不能接受对象作为参数的方法,绑定类方法

非绑定类方法,使用对象去访问

绑定类方法,只能使用类去访问

### 魔术方法

> 和普通方法一样都是类中定义的成员方法
>
> 就是不需要手动调用,魔术方法会在某种情况下,自动触发(自动执行)
>
> 特殊的地方:就是多数的魔术方法,前后都有两个连续的下划线
>
> 不是我们自己定义的,而是系统定义好的,我们来使用

### 初始化方法 __init__

> 触发机制:在通过类实例化对象后,自动触发的一个方法
> 作用: 可以在对象实例化后完成对象的初始化(属性的赋值,方法的调用..)
> 应用场景: 文件的打开,数据的获取...

### 析构方法 __del__ 

```
__del__
    析构方法会在对象被销毁时自动触发
    作用:关闭一些开发的资源
    注意:是对象被销毁时触发了这个方法,而不是这个方法销毁了对象
对象会在哪些情况下被销毁?
    1. 当程序执行完毕, 内存中所有的资源都被销毁释放
    2. 使用 del 删除时
    3. 对象没有被引用时,会自动销毁
```

实例:

定义一个类,完成一个信息的记录,调用类的时候,传递一个日志信息,这个对象会创建一个文件,开始写入,并在最后关闭这个文件.

```python
# coding:utf-8

import time


class WriteLog():
    fileurl = './'  # 文件的路径
    filename = str(time.strftime("%Y-%m-%d"))  # 日志文件的名称

    # 初始化 打开文件
    def __init__(self):
        self.fileobj = open(self.fileurl+self.filename + '.txt', 'a+', encoding="utf-8")

    # 写日志方法
    def log(self, s):
        print(f'把日志:"{s}"写入文件中')

    # 析构方法
    def __del__(self):
        print('析构方法触发了')
        # 在对象被销毁时,关闭在初始化方法中打开的文件对象
        self.fileobj.close()
```

